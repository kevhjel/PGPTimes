<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Driver Profile</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

  <style>
    :root {
      --fg: #e2e8f0;       /* text on dark */
      --muted: #94a3b8;    /* subtle text */
      --bg: #0b1220;       /* page background */
      --card: #111827;     /* panel background */
      --primary: #60a5fa;  /* accents & points */
      --trend: #22d3ee;    /* linear trend (kept for style) */
      --trend-exp: #34d399;/* exponential trendline (green-ish) */
      --ma: #f59e0b;       /* moving average (amber) */
      --border: #1f2937;   /* borders/grid */
      --grid: #253042;     /* chart gridlines */
    }

    html, body {
      margin: 0; padding: 0;
      background: var(--bg); color: var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      line-height: 1.35;
    }
    .wrap { max-width: 980px; margin: 12px auto; padding: 0 12px; }

    header { display: flex; flex-wrap: wrap; align-items: center; gap: 6px 12px; margin-bottom: 10px; }
    h1 { font-size: clamp(18px, 2.6vw, 24px); margin: 0; }
    .subtle { color: var(--muted); font-size: 12px }

    .controls { display: flex; gap: 10px 14px; flex-wrap: wrap; align-items: center; margin: 8px 0 12px }
    .check {
      display: inline-flex; align-items: center; gap: 8px;
      background: var(--card); color: var(--fg);
      border: 1px solid var(--border); border-radius: 8px;
      padding: 6px 10px; font-size: 13px;
    }
    .check input { transform: scale(1.15); accent-color: var(--primary); }
    .btn {
      background: var(--primary); color: #0b1220; border: 0;
      border-radius: 8px; padding: 8px 12px; font-size: 13px; cursor: pointer;
    }

    .card { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 10px }
    .chart-card { margin: 0 auto 12px }

    /* Chart uses 60% of screen height */
    .chart-wrap { position: relative; width: 100%; height: 60vh }

    .stats {
      display: grid; grid-template-columns: repeat(6, minmax(0,1fr));
      gap: 8px; font-size: 12px; margin-bottom: 10px;
    }
    .stat { background: #0f172a; border: 1px solid var(--border);
      border-radius: 8px; padding: 8px; text-align: center }
    .stat .label { display: block; color: var(--muted); font-size: 11px }

    footer { margin: 12px 0 24px; font-size: 13px }
    a { color: var(--primary); text-decoration: none }
    a:hover { text-decoration: underline }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1 id="title">Driver</h1>
      <span class="subtle" id="subtitle"></span>
    </header>

    <div class="controls">
      <label class="check"><input type="checkbox" id="chkOutliers" /> Hide outliers</label>
      <label class="check"><input type="checkbox" id="chkOutLaps" checked /> Ignore out laps</label>
      <label class="check"><input type="checkbox" id="chkTooltips" /> Tooltips</label>
      <button id="btnReset" class="btn">Reset</button>
    </div>

    <div class="card chart-card">
      <div class="chart-wrap"><canvas id="chart"></canvas></div>
    </div>

    <div class="stats" id="statsRow"></div>
    <footer id="driverLink"></footer>
  </div>

<script>
(async function(){
  const SITE_BASE='https://pgpkent.clubspeedtiming.com';
  const DATA_URL='data/all_laps.json';

  const qs=new URLSearchParams(location.search);
  const driverId=qs.get('id')||'';
  const driverName=(qs.get('name')||'').trim();

  // ---------- helpers ----------
  const fmt=(n,d=3)=>Number.isFinite(Number(n))?Number(n).toFixed(d):'–';
  const median=a=>{if(!a.length)return NaN;const s=[...a].sort((x,y)=>x-y);const m=Math.floor(s.length/2);return s.length%2?s[m]:(s[m-1]+s[m])/2;}
  const quantile=(a,q)=>{if(!a.length)return NaN;const s=[...a].sort((x,y)=>x-y);const pos=(s.length-1)*q,base=Math.floor(pos),rest=pos-base;return s[base]+(s[base+1]!==void 0?rest*(s[base+1]-s[base]):0);}
  const iqrBounds=(v,k=1.5)=>{if(!v.length)return{low:-Infinity,high:Infinity};const q1=quantile(v,0.25),q3=quantile(v,0.75),iqr=q3-q1;return{low:q1-k*iqr,high:q3+k*iqr};}
  const buildStats=y=>{const arr=y.filter(v=>!Number.isNaN(v));if(!arr.length)return{count:0,best:NaN,mean:NaN,med:NaN,p90:NaN,latest:NaN};const count=arr.length,best=Math.min(...arr),mean=arr.reduce((a,b)=>a+b,0)/count,med=median(arr),p90=quantile(arr,0.9),latest=arr[arr.length-1];return{count,best,mean,med,p90,latest};}
  const renderStats=(el,s)=>{el.innerHTML=`
    <div class="stat"><span class="label">Laps</span>${s.count}</div>
    <div class="stat"><span class="label">Best</span>${fmt(s.best)}</div>
    <div class="stat"><span class="label">Mean</span>${fmt(s.mean)}</div>
    <div class="stat"><span class="label">Median</span>${fmt(s.med)}</div>
    <div class="stat"><span class="label">p90</span>${fmt(s.p90)}</div>
    <div class="stat"><span class="label">Latest</span>${fmt(s.latest)}</div>`;}

  // ---------- fetch data ----------
  const res=await fetch(DATA_URL,{cache:'no-store'});
  if(!res.ok){document.getElementById('title').textContent='Driver (data error)';return;}
  const payload=await res.json();
  const rows=(payload.rows||[]).filter(r=>r.driver_id===driverId);
  rows.sort((a,b)=>(a.heat_datetime_iso||'').localeCompare(b.heat_datetime_iso||''));

  const displayName=driverName||rows[0]?.driver_name||'Driver';
  document.getElementById('title').textContent=displayName;
  document.getElementById('subtitle').textContent=`${rows.length} laps`;
  document.getElementById('driverLink').innerHTML=
    `<a href="${SITE_BASE}/sp_center/RacerHistory.aspx?CustID=${encodeURIComponent(driverId)}" target="_blank" rel="noopener">View on ClubSpeed ↗</a>`;

  // Prepare data
  const N = rows.length;
  const meta   = rows.map(r=>({ lap:Number(r.lap_number), heat:r.heat_no, date:r.heat_datetime_iso||'' }));
  const yAll   = rows.map(r=>Number(r.lap_seconds));

  // ---------- Chart.js global dark defaults ----------
  Chart.defaults.color = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim();
  Chart.defaults.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim();
  Chart.defaults.plugins.legend.display = false;  // keep clean
  Chart.defaults.animation = false;
  Chart.defaults.responsiveAnimationDuration = 0;

  const ctx=document.getElementById('chart').getContext('2d');

  // Filter toggles
  const chkOutliers = document.getElementById('chkOutliers');
  const chkOutLaps  = document.getElementById('chkOutLaps');
  const chkTooltips = document.getElementById('chkTooltips');

  function filteredPoints(){
    // Base points are scatter points with x=index (1..N), y=lap_seconds
    let pts = yAll.map((y,i)=>({ x: i+1, y, lap: meta[i].lap, heat: meta[i].heat, date: meta[i].date }));

    if (chkOutLaps.checked) {
      pts = pts.map(p => p.lap === 1 ? { ...p, y: NaN } : p);
    }
    if (chkOutliers.checked) {
      const vals = pts.filter(p => !Number.isNaN(p.y)).map(p => p.y);
      const {low, high} = iqrBounds(vals, 1.5);
      pts = pts.map(p => (p.y >= low && p.y <= high) ? p : { ...p, y: NaN });
    }
    return pts;
  }

  // ----- Linear regression (kept for reference/not shown) -----
  function linearRegression(points){
    const pts = points.filter(p => Number.isFinite(p.y));
    const n = pts.length;
    if (n < 2) return { m: 0, b: NaN, ok: false };
    let sumX=0, sumY=0, sumXY=0, sumXX=0;
    for (const p of pts){ sumX+=p.x; sumY+=p.y; sumXY+=p.x*p.y; sumXX+=p.x*p.x; }
    const denom = (n*sumXX - sumX*sumX);
    if (denom === 0) return { m: 0, b: NaN, ok: false };
    const m = (n*sumXY - sumX*sumY) / denom;
    const b = (sumY - m*sumX) / n;
    return { m, b, ok: true };
  }

  // ----- Exponential regression: y = a * e^(b x) -----
  function exponentialRegression(points){
    // Use only finite, positive y (ln(y) defined)
    const pts = points.filter(p => Number.isFinite(p.y) && p.y > 0);
    const n = pts.length;
    if (n < 2) return { a: NaN, b: NaN, ok: false };

    // Fit ln(y) = ln(a) + b x  -> linear least squares on (x, ln y)
    let sumX=0, sumLX=0, sumXX=0, sumL=0;
    for (const p of pts){
      const lx = Math.log(p.y);
      sumX  += p.x;
      sumLX += p.x * lx;
      sumXX += p.x * p.x;
      sumL  += lx;
    }
    const denom = (n * sumXX - sumX * sumX);
    if (denom === 0) return { a: NaN, b: NaN, ok: false };
    const b = (n * sumLX - sumX * sumL) / denom;
    const lnA = (sumL - b * sumX) / n;
    const a = Math.exp(lnA);
    if (!Number.isFinite(a) || !Number.isFinite(b)) return { a: NaN, b: NaN, ok: false };
    return { a, b, ok: true };
  }

  // ----- Moving Average (simple) over visible points -----
  function movingAverage(points, windowSize=20){
    // points: [{x, y, ...}] with NaN holes; result aligns on x with valid centers
    const ys = points.map(p => Number.isFinite(p.y) ? p.y : NaN);
    const xs = points.map(p => p.x);
    const half = Math.floor(windowSize/2);
    const out = [];
    for (let i=0;i<ys.length;i++){
      const left = Math.max(0, i - half);
      const right = Math.min(ys.length - 1, i + half);
      const slice = ys.slice(left, right+1).filter(v => Number.isFinite(v));
      if (slice.length === 0){ out.push({x: xs[i], y: NaN}); continue; }
      const avg = slice.reduce((a,b)=>a+b,0)/slice.length;
      out.push({ x: xs[i], y: avg });
    }
    return out;
  }

  function makeDatasets(){
    const pts = filteredPoints();

    // Scatter dataset (visible points)
    const scatter = {
      type: 'scatter',
      label: 'Lap time (s)',
      data: pts.map(p => ({ x: p.x, y: p.y })),   // keep x indices
      pointRadius: 2,
      pointHoverRadius: 3,
      pointBackgroundColor: 'rgba(96,165,250,0.9)',   // --primary-ish
      pointBorderColor: 'rgba(96,165,250,0.9)',
      showLine: false,
      spanGaps: true,
      parsing: false,
    };

    // Exponential trendline over visible points
    const exp = exponentialRegression(pts);
    let expLine = {
      type: 'line',
      label: 'Exp Trend',
      data: [],
      borderColor: getComputedStyle(document.documentElement).getPropertyValue('--trend-exp').trim() || '#34d399',
      borderWidth: 2,
      pointRadius: 0,
      tension: 0,
      spanGaps: true,
      parsing: false,
    };
    if (exp.ok) {
      const xs = pts.filter(p => Number.isFinite(p.y)).map(p => p.x);
      if (xs.length) {
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        // Sample across domain at integer x so it lines up with data indices
        const curve = [];
        for (let x=minX; x<=maxX; x++){
          const y = exp.a * Math.exp(exp.b * x);
          curve.push({ x, y });
        }
        expLine.data = curve;
      }
    }

    // Moving average over visible points (window = 20)
    const maPts = movingAverage(pts, 20);
    const maLine = {
      type: 'line',
      label: 'Moving Avg (20)',
      data: maPts,
      borderColor: getComputedStyle(document.documentElement).getPropertyValue('--ma').trim() || '#f59e0b',
      borderWidth: 2,
      pointRadius: 0,
      tension: 0.2,
      spanGaps: true,
      parsing: false,
    };

    return [scatter, expLine, maLine];
  }

  function makeOptions(){
    return {
      responsive: true,
      maintainAspectRatio: false,   // CSS height controls canvas
      normalized: true,
      scales: {
        x: {
          type: 'linear',
          min: 1,
          max: Math.max(1, N),
          grid: { color: 'rgba(37,48,66,0.6)' },  // --grid
          ticks: { color: 'var(--muted)' },
          title: { display: true, text: 'Lap # (chronological across heats)' }
        },
        y: {
          grid: { color: 'rgba(37,48,66,0.6)' },
          ticks: { color: 'var(--muted)', callback: v => Number.isFinite(v) ? v.toFixed(0) : '' },
          title: { display: true, text: 'Seconds (lower is faster)' }
        }
      },
      plugins: {
        legend: { display: false },  // keep UI minimal; toggle to true if you want labels visible
        tooltip: {
          enabled: chkTooltips.checked,
          callbacks: {
            title: (items) => {
              const i = items[0].dataIndex;
              return `Point ${i+1}`;
            },
            label: (item) => {
              // For main scatter (dataset 0), include lap/heat in tooltip
              if (item.datasetIndex === 0) {
                const idx = item.dataIndex;
                const p = filteredPoints()[idx];
                const lapStr  = Number.isFinite(p?.lap)  ? `Lap #${p.lap}` : 'Lap –';
                const heatStr = p?.heat ? `Heat ${p.heat}` : 'Heat –';
                const valStr  = Number.isFinite(item.parsed.y) ? `${fmt(item.parsed.y)}s` : '–';
                return ` ${lapStr} • ${heatStr} • ${valStr}`;
              }
              // For lines, just show value
              return ` ${fmt(item.parsed.y)}s`;
            }
          }
        }
      }
    };
  }

  // Build initial chart
  const chart = new Chart(ctx, {
    data: { datasets: makeDatasets() },
    options: makeOptions()
  });

  // Stats
  const statsEl = document.getElementById('statsRow');
  function updateStatsFromChart(){
    const data = chart.data.datasets[0].data.map(p => p.y).filter(v => Number.isFinite(v));
    renderStats(statsEl, buildStats(data));
  }
  updateStatsFromChart();

  // Controls
  function rebuild(){
    chart.data.datasets = makeDatasets();
    chart.options = makeOptions();
    chart.update();
    updateStatsFromChart();
  }

  chkOutliers.onchange = rebuild;
  chkOutLaps.onchange  = rebuild;
  chkTooltips.onchange = rebuild;

  document.getElementById('btnReset').onclick = () => {
    chkOutliers.checked = false;
    chkOutLaps.checked  = true;
    chkTooltips.checked = false;
    rebuild();
    document.querySelector('.chart-card').scrollIntoView({ behavior: 'smooth', block: 'start' });
  };
})();
</script>
</body>
</html>
